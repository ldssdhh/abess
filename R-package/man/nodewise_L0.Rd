% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/abessgraph.R
\name{nodewise_L0}
\alias{nodewise_L0}
\title{Nodewise logistic regression for inverse Ising problem}
\usage{
nodewise_L0(
  x,
  weight = NULL,
  max.support.size = NULL,
  tune.type = "cv",
  c.max = NULL,
  foldid = NULL,
  support.size = NULL,
  ic.scale = 1,
  graph.threshold = 0,
  newton = c("approx", "exact"),
  max.newton.iter = 100,
  sparse = FALSE,
  magnetic = FALSE,
  ...
)
}
\arguments{
\item{x}{Input matrix, of dimension \eqn{n \times p}; each row is an observation
vector and each column is a predictor/feature/variable.
Can be in sparse matrix format (inherit from class \code{"dgCMatrix"} in package \code{Matrix}).}

\item{weight}{Observation weights. When \code{weight = NULL},
we set \code{weight = 1} for each observation as default.}

\item{max.support.size}{}

\item{tune.type}{The type of criterion for choosing the support size.
Available options are \code{"gic"}, \code{"ebic"}, \code{"bic"}, \code{"aic"} and \code{"cv"}.
Default is \code{"gic"}.}

\item{c.max}{an integer splicing size. Default is: \code{c.max = 2}.}

\item{foldid}{an optional integer vector of values between 1, ..., nfolds identifying what fold each observation is in.
The default \code{foldid = NULL} would generate a random foldid.}

\item{support.size}{An integer vector representing the alternative support sizes.
Only used for \code{tune.path = "sequence"}. Default is \code{0:min(n, round(n/(log(log(n))log(p))))}.}

\item{ic.scale}{A non-negative value used for multiplying the penalty term
in information criterion. Default: \code{ic.scale = 1}.}

\item{newton}{A character specify the Newton's method for fitting generalized linear models,
it should be either \code{newton = "exact"} or \code{newton = "approx"}.
If \code{newton = "exact"}, then the exact hessian is used,
while \code{newton = "approx"} uses diagonal entry of the hessian,
and can be faster (especially when \code{family = "cox"}).}

\item{max.newton.iter}{a integer giving the maximal number of Newton's iteration iterations.
Default is \code{max.newton.iter = 10} if \code{newton = "exact"}, and \code{max.newton.iter = 60} if \code{newton = "approx"}.}

\item{...}{further arguments to be passed to or from methods.}
}
\value{

}
\description{
Nodewise logistic regression for inverse Ising problem
}
\examples{
p <- 16
n <- 1e3
library(abess)
train <- generate.bmn.data(n, p, type = 10, graph.seed = 1, seed = 1, beta = 0.4)
res <- nodewise_L0(train[["data"]], train[["weight"]], tune.type = "gic", 
                   max.support.size = rep(4, p), support.size = rep(4, p))
all((res[[1]] != 0) == (train[["theta"]] != 0))

## use cross validation to nodewisely select support.size
valid <- generate.bmn.data(n, p, type = 10, graph.seed = 1, seed = 10000, beta = 0.4)
all(train[["theta"]] == valid[["theta"]])
x <- rbind(train[["data"]], valid[["data"]])
sample_weight <- c(train[["weight"]], valid[["weight"]])
fold_id <- c(rep(1, length(train[["weight"]])), rep(2, length(valid[["weight"]])))
res <- nodewise_L0(x, sample_weight, tune.type = "cv", foldid = fold_id, graph.threshold = 0.2)
all((res[[1]] != 0) == (train[["theta"]] != 0))

## use IC to nodewisely select support.size (without post-thresholding)
res <- nodewise_L0(x, sample_weight, tune.type = "gic", ic.scale = 2)
all((res[[1]] != 0) == (train[["theta"]] != 0))

res <- nodewise_L0(x, sample_weight, tune.type = "gic", ic.scale = 1, graph.threshold = 0.2)
all((res[[1]] != 0) == (train[["theta"]] != 0))

train <- generate.bmn.data(10000 * n, p, type = 8, alpha = 0.9, beta = 0.9, degree = 3, seed = 1)
system.time(res <- nodewise_L0(train[["data"]], train[["weight"]], tune.type = "gic", ic.scale = 1, graph.threshold = 0.2))
mean(res[[1]] - train[["theta"]])
mean(diag(res[[1]]) - diag(train[["theta"]]))
diag(res[[1]]) <- 0
all((res[[1]] != 0) == (train[["theta"]] != 0))
\dontrun{
## simple test suggest that sparsity is not useful
system.time(res <- nodewise_L0(train[["data"]], train[["weight"]], tune.type = "gic", ic.scale = 1, graph.threshold = 0.2, sparse = TRUE))
mean(res[[1]] - train[["theta"]])
mean(diag(res[[1]]) - diag(train[["theta"]]))
diag(res[[1]]) <- 0
all((res[[1]] != 0) == (train[["theta"]] != 0))
}

train <- generate.bmn.data(9000, 48, type = 8, alpha = 0.9, beta = 0.9, degree = 3, method = "gibbs", seed = 1)
system.time(res <- nodewise_L0(train[["data"]], train[["weight"]], tune.type = "gic", ic.scale = 1, graph.threshold = 0.2))
mean(res[[1]] - train[["theta"]])
mean(diag(res[[1]]) - diag(train[["theta"]]))
diag(res[[1]]) <- 0
all((res[[1]] != 0) == (train[["theta"]] != 0))

}
